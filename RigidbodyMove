using UnityEngine;
using UnityEngine.InputSystem;

public class RigidbodyMove : MonoBehaviour
{
    private Rigidbody rb;
    private Transform mainCamera;
    private float moveSpeed = 4f;

    [SerializeField]
    private bool isMoving = false;
    [SerializeField]
    private bool isAttack = false;
    [SerializeField]
    private bool isFalling = false;
    [SerializeField]
    private bool isHitted = false;
    [SerializeField]
    private bool isOnSlope = false;
    [SerializeField]
    private float maxSlopeAngle = 45f;
    [SerializeField]
   private Vector3 worldMoveDirection;
    [SerializeField]
    private Vector3 moveDirection;
    [SerializeField]
    private Vector3 slopeDirection;

    private float vertiGravity;
    private Vector3 _capsuleBottum;
    private Vector3 _capsuleTop;
    private float _capsuleRadius = 0.1f;
    float rayLength = float.MaxValue;
    float radius = 0.5f;

    private Animator anim;
    private void Awake()
    {
        rb = GetComponent<Rigidbody>();
        rb.freezeRotation = true;
        anim = GetComponent<Animator>();
        mainCamera = Camera.main.transform;
    }

    /*
     이동 로직 순서
    추락 여부 계산 => 바닥에 raycast
    추락이 아닐 경우 이동 여부 확인         //추락일 경우 이동 불능 상태로 낙하
    이동일 경우 앞에 장애물이 있는 지 확인  //장애물이 없다면 이동
    장애물이 있을 경우 오를 수 있는 지 확인 //오를 수 없다면 이동 중지
    오를 수 있는/내려갈 수 있는 경사면 이동 //추락과 이동 가능 각도 사이에 등반과 미끄러짐 각도를 추가할 수 있음
     */
    private void Update()
    {
        UpdateAnimation();
        UpdateValue();
        if(isMoving || isAttack)
            UpdateCamRotation();
    }

    private void FixedUpdate()  //<= 이동이 최종적으로 rigidBody를 통해 반영되므로 FixedUpdate에서 반영함
    {
        worldMoveDirection = transform.TransformDirection(moveDirection);
        slopeDirection = transform.TransformDirection(slopeDirection);
        CheckGround();
        StandingOnGround();
        UpdateVeloCity();
    }

    public void OnMove(InputAction.CallbackContext context) //<=이동에 대한 입력을 담당 실제 반영은 위에 FixedUpdate의 rb.veloctiy에서 반영
    {
        if (context.performed)
        {
            isMoving = true;
            Vector2 input = context.ReadValue<Vector2>();
            moveDirection = new Vector3(input.x, 0f, input.y).normalized;
        }
        else if (context.canceled)
        {
            isMoving = false;
            moveDirection = Vector3.zero;
        }
    }

    private void UpdateValue()
    {
        _capsuleBottum = transform.position + Vector3.up * 0.1f;
        _capsuleTop = _capsuleBottum + Vector3.up * 2f;
    }

    private void CheckGround()
    {
        RaycastHit hit;
        if (Physics.CapsuleCast(_capsuleBottum, _capsuleTop, _capsuleRadius, transform.forward,  out hit, 1.1f, -1, QueryTriggerInteraction.Ignore))
        {
            float slopeAngle = Vector3.Angle(hit.normal, Vector3.up);

            isOnSlope = slopeAngle > 0 && slopeAngle <= maxSlopeAngle;

            if (isOnSlope && isMoving)
            {
                Vector3 slopeMoveDirection = Vector3.ProjectOnPlane(moveDirection, hit.normal);
                moveDirection = slopeMoveDirection.normalized;
            }
        }
        else
            isOnSlope = false;
    }

    //오르막길 앞에서 자꾸 추락판정이 생김 해결해야 함
    private void StandingOnGround()
    {
        RaycastHit hit;
        if (Physics.SphereCast(transform.position + Vector3.up * 0.2f ,radius, Vector3.down, out hit, rayLength, -1))
        {
            if (hit.distance > 0.1f)
            {
                isFalling = true;
                vertiGravity = 9.8f;
            }
            else
                isFalling = false;
        }
    }

    private void UpdateCamRotation()
    {
        Vector3 LookRot = new Vector3(0, mainCamera.eulerAngles.y, 0);
        transform.rotation = Quaternion.Lerp
            (
            transform.rotation,
            Quaternion.Euler(LookRot),
            moveSpeed * Time.deltaTime
            );
    }

    private void UpdateVeloCity()
    {
        if (isMoving || !isOnSlope || !isFalling)
            rb.velocity = worldMoveDirection * moveSpeed;
        else if (!isOnSlope && isFalling)
            rb.velocity = worldMoveDirection * moveSpeed + vertiGravity * Vector3.down;
        else if (isOnSlope && isMoving)
            rb.velocity = slopeDirection * moveSpeed;
    }

    /*
    readonly private int attack = Animator.StringToHash("attack");
    readonly private int HoriMove = Animator.StringToHash("HoriMove");  
    readonly private int VertiMove = Animator.StringToHash("VertiMove");
    readonly private int isMove = Animator.StringToHash("isMove");
    readonly private int isRun = Animator.StringToHash("IsRun");
    readonly private int Reaction = Animator.StringToHash("Reaction");
    readonly private int rolling = Animator.StringToHash("Rolling");
    readonly private int sliding = Animator.StringToHash("Sliding");
     */

    private void UpdateAnimation()  //<= bool값을 통해 animation을 제어함
    {
        anim.SetFloat(Constant.AnimatorParams.HoriMove, moveDirection.x);
        anim.SetFloat(Constant.AnimatorParams.VertiMove, moveDirection.z);
        anim.SetBool(Constant.AnimatorParams.IsMove, isMoving);
    }
}
